package com.completeperspective.media.model{	import com.completeperspective.media.events.*;	import com.completeperspective.media.net.*;	import com.completeperspective.media.utils.*;	import com.completeperspective.vo.MediaVO;		import flash.display.*;	import flash.geom.*;	import flash.events.*;	import flash.media.*;	import flash.net.*;	public class ProgressiveVideo extends Sprite	{				public static const VERSION : String = "1.0.1";				private var _nc : NetConnection;		private var _ns : NetStream;		private var _client : SimpleClient;		private var _video : Video;		private var _path : String;		private var _bandwidth : Number;		private var _media : Object;		private var _model : MediaPlayerModel = MediaPlayerModel.getInstance();		private var _loaded : Boolean = false;				public function ProgressiveVideo( bandwidth : Number, path : String )		{			_bandwidth = bandwidth;			_path = path;			_media = _model.nowPlaying;			init();		}				private function init() : void		{			_client = new SimpleClient();			_client.addEventListener(  MetadataEvent.METADATA_RECEIVED, handleMetadata );						_nc = new NetConnection();			_nc.client = _client;			_nc.addEventListener( NetStatusEvent.NET_STATUS, handleConnectionStatus );			_nc.connect( null );						_ns = new NetStream( _nc );			_ns.client = _client;						var buffer : Number = BufferCalculator.calculate( _media.duration, _media.bitrate, _bandwidth );			_ns.bufferTime = buffer;						_ns.addEventListener( NetStatusEvent.NET_STATUS, handleStreamStatus );						_video = new Video();			_video.width = _model.playerWidth;			_video.height = _model.playerHeight;									// If scaling down, smooth the video.			if (_model.playerWidth < _media.width || _model.playerHeight < _media.height )			{				_video.smoothing = true;			}						_video.attachNetStream( _ns );						_ns.play(_path, 0);// + "?uid=" + new Date().getTime(), 0 );						addChild( _video );					}				private function checkBuffer( e : Event ) : void		{			var left : Number = _ns.bufferTime - _ns.bufferLength;						//trace( left );						if ( left <= 0 )			{				if( _loaded ) {					//startVideo();				} else {					_loaded = true;					removeEventListener( Event.ENTER_FRAME, checkBuffer );					addEventListener( Event.ENTER_FRAME, handleEnterFrame );					dispatchEvent( new MediaPlayerEvent( MediaPlayerEvent.BUFFERED, this ) );				}				//trace( this + ": checkBuffer( " + _ns.bufferTime + " )" );				//trace( _ns.bufferLength );			} else {								dispatchEvent( new MediaPlayerEvent( MediaPlayerEvent.BUFFERING, left ) );			}		} 				private function handleEnterFrame( e : Event ) : void		{			var now : Number = Math.round( _ns.time );			var then : Number = Math.round( _media.duration );						if ( now >= then ) 			{				removeEventListener( Event.ENTER_FRAME, handleEnterFrame );				dispatchEvent( new MediaPlayerEvent( MediaPlayerEvent.FINISHED, this ) );			}		}				public function startVideo() : void		{			addEventListener( Event.ENTER_FRAME, handleEnterFrame );			_ns.seek( 0 );			_ns.resume();		}				private function handleConnectionStatus( e : NetStatusEvent ) : void		{			trace( this + ": " + e.info.code );		}				public function handleFullScreen() : void		{			var scalingRect:Rectangle = new Rectangle(_video.x, _video.y, _video.width, _video.height);			stage["fullScreenSourceRect"] = scalingRect;						if(stage.displayState == StageDisplayState.NORMAL)			{				stage.displayState = StageDisplayState.FULL_SCREEN;			}			else			{				stage.displayState = StageDisplayState.NORMAL;			}		}				private function handleMetadata( e : MetadataEvent ) : void		{			_media.duration = e.data.duration;		}				private function handleStreamStatus( e : NetStatusEvent = null ) : void		{			trace( this + ": " + e.info.code );			switch( e.info.code )			{				case "NetStream.Play.Start":					_ns.togglePause();					trace( this + "pause until buffer is full" );					addEventListener( Event.ENTER_FRAME, checkBuffer );					break;				case "NetStream.Play.Stop":					dispatchEvent( e );					break;				case "NetStream.Buffer.Empty":					// Data is not being received quickly enough to fill the buffer. 					// Data flow will be interrupted until the buffer refills, at which time a NetStream.Buffer.Full 					// message will be sent and the stream will begin playing again.					_ns.bufferTime -= 60;					trace( this + ": Buffer reset > " + _ns.bufferTime );					dispatchEvent( e );										break;				case "NetStream.Buffer.Full":					// The buffer is full and the stream will begin playing.					_ns.bufferTime += 60;					dispatchEvent( e );					break;				case "NetStream.Buffer.Flush":					// Data has finished streaming, and the remaining buffer will be emptied.					break;				case "NetStream.FileStructureInvalid":					trace("The MP4's file structure is invalid.");					break;				case "NetStream.NoSupportedTrackFound":					trace("The MP4 doesn't contain any supported tracks");					break;			}			}		public function getTimeCode( myTime : Number ) : String 		{			var tempNum = myTime;			var minutes = Math.floor(tempNum / 60);			var _displayHours : Boolean = true;						if (_displayHours) 			{				var hours = Math.floor(minutes / 60);			}			var seconds = Math.round(tempNum - (minutes * 60));						if (seconds < 10) 			{				seconds = "0" + seconds;			}			if (minutes < 10) 			{				minutes = "0" + minutes;			}						if (_displayHours) 			{				if (hours < 10) 				{					hours = "0" + hours;				}			}						var timeCode : String = minutes + ":" + seconds;						return timeCode;		}						public function get media() : Object		{			return _media;		}				public function get ns() : NetStream 		{			return _ns;		}				override public function toString():String		{			return "[ProgressiveVideo v" + VERSION + "]";		}	}}